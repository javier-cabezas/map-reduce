#ifndef GMAP_MAPREDUCE_
#define GMAP_MAPREDUCE_

#include <compiler>
#include <functional>
#include <omp.h>
#include <ndarray>
#include <range>

#ifdef __GXX_EXPERIMENTAL_CXX0X__

template<typename MembFuncPtr> 
struct memb_func_traits 
{}; 

template< typename ClassT, typename R, typename... Arg> 
struct memb_func_traits<R  ClassT::* (Arg...)> 
{ 
     using class_type = ClassT; 
     using signature = R (Arg...); 
}; 

template< typename ClassT, typename R, typename... Arg> 
struct memb_func_traits<R (ClassT::*) (Arg...) const> 
{ 
     using class_type = ClassT; 
     using signature = R (Arg...); 
}; 

template<typename F> 
struct reduce_traits { 
     typedef typename memb_func_traits< 
                 decltype(&F::operator()) 
             >::signature signature; 

     typedef std::function<signature> type; 
     typedef typename std::function<signature>::result_type return_type; 
}; 

template <unsigned Level, typename Func, typename Range>
struct wrapper_map {
    template<typename... Args>
    void static map(Func f, const Range &r, Args &&... args)
    {
        typedef iterator<typename Range::type> myit;
        typedef dim_type<typename Range::type> mydim;

        mydim d = r.get_dim(sizeof...(Args));

        for (typename Range::type t  = d.begin;
                                   t  < d.end;
                                   t += d.step) {
            wrapper_map<Level - 1, Func, Range>::map(f, r, args..., t);
        }
    }


    void static map(Func f, const Range &r)
    {
        typedef iterator<typename Range::type> myit;
        typedef dim_type<typename Range::type> mydim;

        mydim d = r.get_dim(0);

        #pragma omp parallel for
        for (typename Range::type t  = d.begin;
                                   t  < d.end;
                                   t += d.step) {
            wrapper_map<Level - 1, Func, Range>::map(f, r, t);
        }
    }
};

template <typename Func, typename Range>
struct wrapper_map<0, Func, Range> {
    template<typename... Args>
    void static map(Func f, const Range &r, Args &&... args)
    {
        f(args...);
    }
};

template <unsigned Level, typename Access, typename Range>
struct expand {
    template<typename... Args>
    typename reduce_traits<Access>::return_type
    static invoke(Access a, const Range &r, Args &&... args)
    {
        return expand<Level - 1, Access, Range>::invoke(a, r, args..., r.get_dim(sizeof...(Args)).begin);
    }
};

template <typename Access, typename Range>
struct expand<0, Access, Range> {
    template<typename... Args>
    typename reduce_traits<Access>::return_type
    static invoke(Access a, const Range &r, Args &&... args)
    {
        return a(args...);
    }
};

template <unsigned Level, typename Access, typename Func, typename Range>
struct wrapper_reduce {
    template<typename... Args>
    typename reduce_traits<Func>::return_type
    static reduce(Access a, Func f, const Range &r, typename reduce_traits<Func>::return_type tmp, Args &&... args)
    {
        typedef iterator<typename Range::type> myit;
        typedef dim_type<typename Range::type> mydim;

        mydim d = r.get_dim(sizeof...(Args));

        for (typename Range::type t  = d.begin;
                                  t  < d.end;
                                  t += d.step) {
            tmp = wrapper_reduce<Level - 1, Access, Func, Range>::reduce(a, f, r, tmp, args..., t);
        }

        return tmp;
    }

    typename reduce_traits<Func>::return_type
    static reduce(Access a, Func f, const Range &r)
    {
        typedef iterator<typename Range::type> myit;
        typedef dim_type<typename Range::type> mydim;

        mydim d = r.get_dim(0);

        typename reduce_traits<Func>::return_type ret = expand<Level - 1, Access, Range>::invoke(a, r, d.begin);
        size_t steps = (d.end - d.begin) / d.step;

        size_t chunks;
        if (steps >= omp_get_num_procs()) {
            chunks = omp_get_num_procs();
        } else {
            chunks = 1;
        }
        size_t local_steps = steps / chunks;

        #pragma omp parallel for shared(ret)
        for (size_t i = 0; i < chunks; ++i) {
            typename reduce_traits<Func>::return_type partial = expand<Level - 1, Access, Range>::invoke(a, r, d.begin + i * local_steps);
            for (typename Range::type t  = d.begin + i * local_steps;
                                      t  < d.begin + (i + 1) * local_steps;
                                      t += d.step) {
                partial = wrapper_reduce<Level - 1, Access, Func, Range>::reduce(a, f, r, partial, t);
            }
            #pragma omp critical
            ret = f(partial, ret);
        }

        return ret;
    }
};

template <typename Access, typename Func, typename Range>
struct wrapper_reduce<0, Access, Func, Range> {
    template<typename... Args>
    typename reduce_traits<Func>::return_type static reduce(Access a, Func f, const Range &r, typename reduce_traits<Func>::return_type tmp, Args &&... args)
    {
        return f(a(args...), tmp);
    }
};

template <typename Func, typename Range>
static
void map(Func f, const Range &r)
{
    wrapper_map<Range::NDims, Func, Range>::map(f, r);
}

template <typename Func, typename T>
static
void map(Func f, const dim_type<T>& d)
{
    wrapper_map<1, Func, range<1, T> >::map(f, make_range(d));
}

template <typename Func, typename T, typename... Dims>
static
void map(Func f, const dim_type<T>& d, const Dims &... dims)
{
    wrapper_map<1 + sizeof...(Dims), Func, range<1 + sizeof...(Dims), T> >::map(f, make_range(d, dims...));
}

template <typename Func, typename... Dims>
static
void map(Func f, const dim_type<int>& d, const Dims &... dims)
{
    map<Func, int, Dims...>(f, d, dims...);
}

template <typename Access, typename Func, typename Range>
static
typename reduce_traits<Func>::return_type reduce(Access a,
                                                 Func f,
                                                 const Range &r)
{
    return wrapper_reduce<Range::NDims, Access, Func, Range>::reduce(a, f, r);
}

template <typename Access, typename Func, typename T>
static
typename reduce_traits<Func>::return_type reduce(Access a,
                                                 Func f,
                                                 const dim_type<T>& d)
{
    return wrapper_reduce<1, Access, Func, range<1, T> >::reduce(a, f, make_range(d));
}

template <typename Access, typename Func, typename T, typename... Dims>
static
typename reduce_traits<Func>::return_type reduce(Access a,
                                                 Func f,
                                                 const dim_type<T>& d,
                                                 const Dims &... dims)
{
    return wrapper_reduce<1 + sizeof...(Dims), Access, Func, range<1 + sizeof...(Dims), T> >::reduce(a, f, make_range(d, dims...));
}

template <typename Access, typename Func, typename... Dims>
static
typename reduce_traits<Func>::return_type reduce(Access a,
                                                 Func f,
                                                 const dim_type<int> &d,
                                                 const Dims &... dims)
{
    return reduce<Access, Func, int, Dims...>(a, f, d, dims...);
}
#else

#endif

#endif

/* vim:set ft=cpp backspace=2 tabstop=4 shiftwidth=4 textwidth=120 foldmethod=marker expandtab: */
